const std = @import("std");
const git = @import("git.zig");
const helper = @import("helper.zig");

pub const WorkspaceError = error{
    InitWorkspaceCreationFailed,
    InitAccessDenied,
    InitNotOnMainBranch,
};

const InitResult = enum {
    initialized,
    reinitialized,
};

pub fn init(allocator: std.mem.Allocator) WorkspaceError!InitResult {
    const tix = ".tix";

    std.fs.cwd().makePath(tix) catch |err| switch (err) {
        error.AccessDenied => return WorkspaceError.InitAccessDenied,
        else => return WorkspaceError.InitWorkspaceCreationFailed,
    };
    const git_exists = if (std.fs.cwd().access(".tix/.git", .{})) |_| true else |_| false;

    errdefer if (!git_exists) std.fs.cwd().deleteTree(tix) catch {};

    helper.addTixToGitIgnore(allocator) catch {};

    git.init(allocator) catch {
        return WorkspaceError.InitWorkspaceCreationFailed;
    };

    if (git_exists) {
        const current_branch = git.getCurrentBranch(allocator) catch {
            return WorkspaceError.InitWorkspaceCreationFailed;
        };
        defer allocator.free(current_branch);
        
        if (!std.mem.eql(u8, current_branch, "main")) {
            return WorkspaceError.InitNotOnMainBranch;
        }
    }

    const readme_exists = if (std.fs.cwd().access(".tix/README.md", .{})) |_| true else |_| false;
    
    createReadme(allocator) catch {};

    const commit_message = if (git_exists) "Workspace Reinitialized" else "Workspace Initialized";
    
    if (readme_exists) {
        // README already existed, nothing new to commit
        git.commitEmpty(allocator, commit_message) catch {
            return WorkspaceError.InitWorkspaceCreationFailed;
        };
    } else {
        // README was created, stage and commit it
        const paths = [_][]const u8{"README.md"};
        git.add(allocator, &paths) catch {};
        git.commit(allocator, commit_message) catch {
            return WorkspaceError.InitWorkspaceCreationFailed;
        };
    }

    return if (git_exists) .reinitialized else .initialized;
}


fn createReadme(allocator: std.mem.Allocator) !void {
    _ = allocator;
    const readme_path = ".tix/README.md";

    // Don't overwrite existing README
    if (std.fs.cwd().access(readme_path, .{})) |_| return else |_| {}

    const readme_content = 
\\# Tix Ticket Workspace
\\
\\<!-- This README is auto-generated by tix init. Do not edit manually. -->
\\
\\This repository contains tickets managed by [tix](https://github.com/nicolaou-dev/tix-cli) - a git-native project management tool.
\\
\\## Installation
\\
\\See the [tix installation guide](https://github.com/nicolaou-dev/tix-cli#readme) for setup instructions.
\\
\\## Quick Start
\\
\\```bash
\\# Clone this workspace
\\tix clone <this-repo-url>
\\
\\# View tickets
\\tix ls
\\
\\# Add a ticket  
\\tix add -t "Fix login bug" -b "Details..."
\\
\\# Move through workflow
\\tix mv TICKET_ID doing
\\tix mv TICKET_ID done
\\```
\\
\\## Structure
\\
\\Tickets are stored in `.tix/` as git-tracked directories. Each ticket has:
\\- `title.md` - Ticket title
\\- `body.md` - Description  
\\- `s=status` - Current status (todo/doing/done)
\\- `p=priority` - Priority level (a/b/c/z)
\\
\\All changes are automatically committed to git for full audit trail.
    ;

    const file = std.fs.cwd().createFile(readme_path, .{}) catch return;
    defer file.close();
    file.writeAll(readme_content) catch return;
}

test "init create a new Tix workspace" {
    const test_helper = @import("test_helper.zig");
    const allocator = std.testing.allocator;

    // Setup isolated test directory
    const original = try test_helper.setupTestDir(allocator, "init_test");
    defer test_helper.cleanupTestDir("init_test", original);

    const result = try init(allocator);
    try std.testing.expect(result == .initialized);

    // Check .tix directory exists
    try std.fs.cwd().access(".tix", .{});

    // Check .tix/.git directory exists
    try std.fs.cwd().access(".tix/.git", .{});

    // Check .gitignore file exists and contains .tix
    const gitignore_contents = try std.fs.cwd().readFileAlloc(allocator, ".gitignore", 1024 * 1024);
    defer allocator.free(gitignore_contents);
    try std.testing.expect(std.mem.indexOf(u8, gitignore_contents, ".tix") != null);

    // Check README.md exists in .tix directory
    try std.fs.cwd().access(".tix/README.md", .{});
    
    const readme_contents = try std.fs.cwd().readFileAlloc(allocator, ".tix/README.md", 4096);
    defer allocator.free(readme_contents);
    try std.testing.expect(std.mem.indexOf(u8, readme_contents, "Tix Ticket Workspace") != null);
    try std.testing.expect(std.mem.indexOf(u8, readme_contents, "auto-generated by tix init") != null);

    // Re-initialize should return reinitialized
    const result2 = try init(allocator);
    try std.testing.expect(result2 == .reinitialized);
}

test ".tix is not deleted on reinitialization failure" {
    const test_helper = @import("test_helper.zig");
    const allocator = std.testing.allocator;

    // Setup isolated test directory
    const original = try test_helper.setupTestDir(allocator, "reinit_test");
    defer test_helper.cleanupTestDir("reinit_test", original);

    // First successful init
    _ = try init(allocator);

    // Create a ticket to verify it's preserved
    try std.fs.cwd().makePath(".tix/01234567890123456789012345");

    // Make git.init fail by creating a file at .tix/.git (instead of directory)
    try std.fs.cwd().deleteTree(".tix/.git");
    const file = try std.fs.cwd().createFile(".tix/.git", .{});
    defer file.close();

    // This should fail but not delete .tix
    _ = init(allocator) catch {};

    // Verify .tix and our ticket still exist
    try std.fs.cwd().access(".tix", .{});
    try std.fs.cwd().access(".tix/01234567890123456789012345", .{});
}

test "addTixToGitIgnore creates new .gitignore with .tix" {
    const test_helper = @import("test_helper.zig");
    const allocator = std.testing.allocator;

    // Setup isolated test directory
    const original = try test_helper.setupTestDir(allocator, "gitignore_new_test");
    defer test_helper.cleanupTestDir("gitignore_new_test", original);

    try helper.addTixToGitIgnore(allocator);

    // Check .gitignore file exists and contains .tix
    const gitignore_contents = try std.fs.cwd().readFileAlloc(allocator, ".gitignore", 1024 * 1024);
    defer allocator.free(gitignore_contents);
    try std.testing.expect(std.mem.indexOf(u8, gitignore_contents, ".tix") != null);
}

test "addTixToGitIgnore appends .tix if .gitignore exists without it" {
    const test_helper = @import("test_helper.zig");
    const allocator = std.testing.allocator;

    // Setup isolated test directory
    const original = try test_helper.setupTestDir(allocator, "gitignore_append_test");
    defer test_helper.cleanupTestDir("gitignore_append_test", original);

    // Create an existing .gitignore file without .tix
    const file = try std.fs.cwd().createFile(".gitignore", .{});
    defer file.close();
    try file.writeAll("node_modules\n");
    try file.writeAll("dist\n");

    try helper.addTixToGitIgnore(allocator);

    // Check .gitignore file exists and contains .tix
    const gitignore_contents = try std.fs.cwd().readFileAlloc(allocator, ".gitignore", 1024 * 1024);
    defer allocator.free(gitignore_contents);
    try std.testing.expect(std.mem.indexOf(u8, gitignore_contents, ".tix") != null);
    try std.testing.expect(std.mem.indexOf(u8, gitignore_contents, "node_modules") != null);
    try std.testing.expect(std.mem.indexOf(u8, gitignore_contents, "dist") != null);
}

test "addTixToGitIgnore idempotent - doesn't add twice" {
    const test_helper = @import("test_helper.zig");
    const allocator = std.testing.allocator;

    // Setup isolated test directory
    const original = try test_helper.setupTestDir(allocator, "gitignore_idempotent_test");
    defer test_helper.cleanupTestDir("gitignore_idempotent_test", original);

    // Call twice
    try helper.addTixToGitIgnore(allocator);
    try helper.addTixToGitIgnore(allocator);

    const contents = try std.fs.cwd().readFileAlloc(allocator, ".gitignore", 1024);
    defer allocator.free(contents);

    // Should only have one .tix entry
    try std.testing.expectEqualStrings(".tix\n", contents);
}
